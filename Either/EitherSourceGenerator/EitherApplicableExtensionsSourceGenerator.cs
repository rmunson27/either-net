using System;
using System.Linq;
using System.Text;

namespace Rem.Core.Utilities.Monads.SourceGeneration;

/// <summary>
/// Generates a static class that contains apply methods for the "either" monad defined in this solution.
/// </summary>
[Generator]
public class EitherApplicableExtensionsSourceGenerator : ISourceGenerator
{
    #region Constants
    private const string Namespace = "Rem.Core.Utilities.Monads";
    private const string TypeName = "EitherApplicableExtensions";
    #endregion

    #region Generation
    /// <inheritdoc/>
    public void Execute(GeneratorExecutionContext context)
    {
        // Build up the source code
        // Start with the class definition and doc comment
        // Need to explicitly enable `nullable` context
        StringBuilder sourceBuilder = new($@"// <auto-generated/>

#nullable enable

using System;

namespace {Namespace};

/// <summary>
/// Applicable extension methods for instances of <see cref=""Either{{TLeft, TRight}}"".
/// </summary>
public static class {TypeName}
{{
");

        // Add all methods starting with the no-argument versions and progressing to the 16-argument versions
        sourceBuilder.Append(GetNoArgsMethodsString());
        sourceBuilder.AppendLine();
        sourceBuilder.Append(GetSingleArgMethodsString());
        for (int i = 2; i <= 16; i++)
        {
            sourceBuilder.AppendLine();
            sourceBuilder.Append(GetMultipleArgMethodsString(i));
        }

        // Add the end of the class
        sourceBuilder.Append($@"
}}");

        // Add the generated file to the context
        context.AddSource($"{TypeName}.g.cs", sourceBuilder.ToString());
    }

    /// <inheritdoc/>
    /// <remarks>
    /// This method does nothing, as there is no initialization required for this generator.
    /// </remarks>
    public void Initialize(GeneratorInitializationContext context)
    {
        //
    }
    #endregion

    #region Helpers
    private static string GetNoArgsMethodsString()
        => @"
    /// <summary>
    /// Calls the function on the left side of the current instance.
    /// </summary>
    /// <typeparam name=""TLeftResult"">The return type of the left side.</typeparam>
    /// <typeparam name=""TRight"">The type of the right side.</typeparam>
    /// <param name=""either""></param>
    /// <returns></returns>
    public static Either<TLeftResult, TRight> ApplyLeft<TLeftResult, TRight>(
        this Either<Func<TLeftResult>, TRight> either)
        => either.IsRight ? new(either._right) : new(either._left());

    /// <summary>
    /// Calls the function on the right side of the current instance.
    /// </summary>
    /// <typeparam name=""TLeft"">The type of the left side.</typeparam>
    /// <typeparam name=""TRightResult"">The return type of the right side.</typeparam>
    /// <param name=""either""></param>
    /// <returns></returns>
    public static Either<TLeft, TRightResult> ApplyRight<TLeft, TRightResult>(
        this Either<TLeft, Func<TRightResult>> either)
        => either.IsRight ? new(either._right()) : new(either._left);
";

    private static string GetSingleArgMethodsString()
        => @"
    /// <summary>
    /// Applies the function on the left side of the current instance to the supplied argument.
    /// </summary>
    /// <typeparam name=""TArg"">The type of the argument of the left side.</typeparam>
    /// <typeparam name=""TLeftResult"">The return type of the left side.</typeparam>
    /// <typeparam name=""TRight"">The type of the right side.</typeparam>
    /// <param name=""either""></param>
    /// <param name=""arg"">The argument to apply the left side to.</param>
    /// <returns></returns>
    public static Either<TLeftResult, TRight> ApplyLeft<TArg, TLeftResult, TRight>(
        this Either<Func<TArg, TLeftResult>, TRight> either, TArg arg)
        => either.IsRight ? new(either._right) : new(either._left(arg));

    /// <summary>
    /// Applies the function on the right side of the current instance to the supplied argument.
    /// </summary>
    /// <typeparam name=""TLeft"">The type of the left side.</typeparam>
    /// <typeparam name=""TArg"">The type of the argument of the right side.</typeparam>
    /// <typeparam name=""TRightResult"">The return type of the right side.</typeparam>
    /// <param name=""either""></param>
    /// <param name=""arg"">The argument to apply the right side to.</param>
    /// <returns></returns>
    public static Either<TLeft, TRightResult> ApplyRight<TLeft, TArg, TRightResult>(
        this Either<TLeft, Func<TArg, TRightResult>> either, TArg arg)
        => either.IsRight ? new(either._right(arg)) : new(either._left);
";

    private static string GetMultipleArgMethodsString(int argCount)
    {
        #region Static Helpers
        static string FuncArgTypeName(int number) => $"TArg{number}";

        static string FuncArgName(int number) => $"arg{number}";
        #endregion

        #region Setup
        var argNumberRange = Enumerable.Range(1, argCount);

        var funcArgTypeList = argNumberRange.Select(FuncArgTypeName);

        var funcArgNameList = argNumberRange.Select(FuncArgName);

        var funcArgTypeListStr = string.Join(", ", funcArgTypeList);

        var funcArgNameListStr = string.Join(", ", funcArgNameList);

        string FuncArgTypeDocsStr(EitherSide side)
            => string.Join(
                Environment.NewLine,
                funcArgTypeList.Zip(
                    argNumberRange,
                    (tStr, i)
                        => "    /// "
                            + TypeArgDocStr(
                                tStr,
                                $"The type of the {i.FormatAsOrdinal()} argument of the"
                                    + $" {side.ToString().ToLower()} side.")));

        string FuncArgDocsStr(EitherSide side)
            => string.Join(
                Environment.NewLine,
                funcArgNameList.Zip(
                    argNumberRange,
                    (pName, i)
                        => "    /// "
                            + ParamDocStr(
                                pName,
                                $"The {i.FormatAsOrdinal()} argument to apply the"
                                    + $" {side.ToString().ToLower()} side to.")));

        string EitherTypeStr(EitherSide side)
            => side == EitherSide.Left
                ? $"Either<{FuncTypeStr(EitherSide.Left)}, TRight>"
                : $"Either<TLeft, {FuncTypeStr(EitherSide.Right)}>";

        string ArgDeclarationsListStr(EitherSide side)
            => $"this {EitherTypeStr(side)} either, "
                + string.Join(", ", funcArgTypeList.Zip(funcArgNameList, (type, name) => $"{type} {name}"));

        string FuncTypeStr(EitherSide side) => $"Func<{funcArgTypeListStr}, {FuncResultTypeStr(side)}>";
        #endregion

        return $@"
    /// <summary>
    /// Applies the function on the left side of the current instance to the arguments passed in.
    /// </summary>
{FuncArgTypeDocsStr(EitherSide.Left)}
    /// <typeparam name=""TLeftResult"">The return type of the left side.</typeparam>
    /// <typeparam name=""TRight"">The type of the right side.</typeparam>
    /// <param name=""either""></param>
{FuncArgDocsStr(EitherSide.Left)}
    /// <returns></returns>
    public static Either<TLeftResult, TRight> ApplyLeft<{funcArgTypeListStr}, TLeftResult, TRight>(
        {ArgDeclarationsListStr(EitherSide.Left)})
        => either.IsRight ? new(either._right) : new(either._left({funcArgNameListStr}));

    /// <summary>
    /// Applies the function on the right side of the current instance to the arguments passed in.
    /// </summary>
    /// <typeparam name=""TLeft"">The type of the left side.</typeparam>
{FuncArgTypeDocsStr(EitherSide.Right)}
    /// <typeparam name=""TRightResult"">The return type of the right side.</typeparam>
    /// <param name=""either""></param>
{FuncArgDocsStr(EitherSide.Right)}
    /// <returns></returns>
    public static Either<TLeft, TRightResult> ApplyRight<TLeft, {funcArgTypeListStr}, TRightResult>(
        {ArgDeclarationsListStr(EitherSide.Right)})
        => either.IsRight ? new(either._right({funcArgNameListStr})) : new(either._left);
";
    }

    private static string FuncResultTypeStr(EitherSide side)
        => side == EitherSide.Left ? "TLeftResult" : "TRightResult";

    private static string TypeArgDocStr(string name, string description)
        => $"<typeparam name=\"{name}\">{description}</typeparam>";

    private static string ParamDocStr(string name, string description)
        => $"<param name=\"{name}\">{description}</param>";
    #endregion
}
